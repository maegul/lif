<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>lif.rf_stim API documentation</title>
<meta name="description" content="Module for generation of stimuli" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lif.rf_stim</code></h1>
</header>
<section id="section-intro">
<p>Module for generation of stimuli</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module for generation of stimuli


&#34;&#34;&#34;

import numpy as np
import matplotlib.pyplot as plt

import pyqtgraph as pg
from pyqtgraph.Qt import QtGui


def mk_coords(
        spat_res=1, temp_res=1,
        spat_ext=300, temp_ext=1000,
        temp_dim=True, blank_grid=False):
    &#39;&#39;&#39;
    Produces spatial and temporal coordinates (ie meshgrid) for
    generating RFs and stimuli
    Base units are minutes of arc and milliSeconds

    Parameters
    ----
    spat_res : float
        resolution, in minutes of arc, of meshgrid
    temp_res : float
        resolution, in milliseconds, of temporal dimension of meshgrid
    spat_ext : int
        Width and height, in minutes of arc, of spatial dimensions of meshgrid
        spat_ext is the total width (horiztontal or vertical) of the stimulus
        image generated.
        radial extent (horizontal or vertical, from center) will be
        floor(spat_ext/2), and always centred on zero.
        So actual extent will be 1*spat_res greater for even and as specified
        for odd extents
    temp_ext : int
        duration, in milliseconds, of temporal dimension
    temp_dim : boolean
        Whether to include a temporal dimension in the meshgrid
    blank_grid : boolean
        Whether to return a meshhgrid with all values being zero
        Useful for filling in the grid manually for stimulus creation

    Returns
    ----
    xc, yc, tc (if temp_dim)
    xc, yc if temp_dim==false

    all meshgrids filled with appropriate coordinate values
    If blank_grid, then single meshgrid (3D: x,y,t)
    &#39;&#39;&#39;

    spat_radius = np.floor(spat_ext / 2)
    x_coords = np.arange(-spat_radius, spat_radius + spat_res, spat_res)
    # treat as image (with origin at top left or upper)
    # y_cords positive at top and negative at bottom
    y_coords = x_coords[::-1]

    t_coords = np.arange(0, temp_ext, temp_res)

    # ie, one array with appropriate size, each coordinate represented by a single value
    if blank_grid:
        space = np.zeros((y_coords.size, x_coords.size, t_coords.size))
        return space

    if not temp_dim:
        xc, yc = np.meshgrid(x_coords, y_coords)
        return xc, yc
    else:
        xc, yc, tc = np.meshgrid(x_coords, y_coords, t_coords)
        return xc, yc, tc


def mk_rf(
        spat_res=1,
        cent_h_sd=10.6, cent_v_sd=10.6, surr_h_sd=31.8, surr_v_sd=31.8,
        mag_cent=1, mag_surr=1,
        rf_sd_limit=5,
        return_cent_surr=False, return_coords=False):
    &#39;&#39;&#39;Generate DoG Rec Field

    Parameters
    ----
    spat_res : float
        resolution of meshgrid used to create RF
        passed to mk_coords
    cent/surr_h/v_sd : float
        standard dev of gaussian used to generate RF
        cent/surr -&gt; center or surround component
        h/v : vertical or horizontal axis
    mag_cent/surr : float
        absolute magnitude of cent/surr component
    rf_sd_limit : float
        span of underlying mesdhgrid in number of standard deviations
        the maximum of of all cent/surr_h/v_sd are used
        important to ensure that the sum of the surround is not arbitrarily
        trunacated
    return_cent_surr : boolean
        whether to return the center and surround components also
    return_coords : boolean
        whether to also return the meshgrid for x and y

    Units are defined in arc minutes

    Current defaults from Woergoetter and Koch (1991)

    Returns
    ----

    &#39;&#39;&#39;

    # integer rounded max sd times rf_sd_limit -&gt; img limit for RF
    max_sd = rf_sd_limit * np.ceil(
        np.max([cent_h_sd, cent_v_sd, surr_h_sd, surr_v_sd])
    )
    # spatial extent (for mk_coords)
    # add 1 to ensure number is odd so size of mk_coords output is as specified
    spat_ext = (2 * max_sd) + 1

    # only one coords necessary, as square/cartesion grid (how to noise hexagonal centering?)
    x_coords, y_coords = mk_coords(spat_res=spat_res, spat_ext=spat_ext, temp_dim=False)

    rf_cent = (
        # mag divide by normalising factor with both sds (equivalent to sq if they were identical)
        (mag_cent / (2 * np.pi * cent_v_sd * cent_h_sd)) *
        np.exp(
            - (
                (x_coords**2 / (2 * cent_h_sd**2)) +
                (y_coords**2 / (2 * cent_v_sd**2))
            )
        )
    )

    rf_surr = (
        (mag_surr / (2 * np.pi * surr_v_sd * surr_h_sd)) *
        np.exp(
            - (
                (x_coords**2 / (2 * surr_h_sd**2)) +
                (y_coords**2 / (2 * surr_v_sd**2))
            )
        )
    )

    rf = rf_cent - rf_surr

    if not (return_cent_surr or return_coords):

        return rf

    else:
        ret_vars = (rf,)

        if return_cent_surr:
            ret_vars += rf_cent, rf_surr
        if return_coords:
            ret_vars += x_coords, y_coords

        return ret_vars


def mk_tempfilt(tau=10, temp_ext=100, temp_res=1, temp_ext_n_tau=None, return_t=False):
    &#39;&#39;&#39;Generate a temporal filter

    All time parameters in milliseconds

    Parameters
    ----
    tau : float
        Time constant
    temp_ext : float
        Length of temporal filter
    temp_res : float
        resolution of temporal filter
        size of temporal increment in milliseconds
    temp_ext_n_tau : int (Default None)
        length of temporl filter but in number of tau (time constants)
        If None, temp_ext used instead, if int, this is used
    return_t : Boolean
        If True, return time units array as well as magnitude of filer
        Else, return just the filter

    Maths and values taken from worgotter and koch (1991)
    &#39;&#39;&#39;

    # Use number of time consts as measure of temp extend, if specified
    if temp_ext_n_tau:
        temp_ext = temp_ext_n_tau * tau

    t = np.arange(0, temp_ext, temp_res)
    tf = np.exp(-t / tau) / tau

    if return_t:
        return t, tf
    else:
        return tf


def mk_tempfilt2(
        tau1=10, tau2=20,
        temp_res=1, temp_ext_n_tau=5, return_t=True,
        correct_integral_errors=True):
    &#34;&#34;&#34;Generate two temporal filters with different time constants

    As with mk_tempfilt but with two taus


    Parameters
    ----
    correct_integral_errors : Boolean
        Ensure that both temporal filters sum to 1
        Necessary due to discretisation errors and need
        to ensure both filters do not alter the magnitude of the
        input signal.
        Done by dividing the temporal filter by the sum of the filter

    Returns
    ----
    tf1, tf2 : array (1D)
        EAch as the output of mk_tempfilt
        Magnitude of the filter at each time step in 1D filter
    &#34;&#34;&#34;

    temp_ext = max([tau1, tau2]) * temp_ext_n_tau
    t, tf1 = mk_tempfilt(tau1, temp_ext, temp_res=temp_res, return_t=True)
    tf2 = mk_tempfilt(tau2, temp_ext, temp_res=temp_res)

    if correct_integral_errors:
        tf1 /= tf1.sum()
        tf2 /= tf2.sum()

    if return_t:
        return t, tf1, tf2
    else:
        return tf1, tf2


def mk_tqtempfilt(
        tau=16, w=4 * 2 * np.pi, phi=0.24,
        temp_ext=100, temp_ext_n_tau=None,
        temp_res=1, return_t=True):
    r&#34;&#34;&#34;Generate single temp filter by modulating a negative exp with a cosine

    Parameters
    ----
    tau : float (milliseconds)
        Time constant of negative exponential
    w : float (n*2*pi radians)
        Frequency of modulation of negative exp
        As in &#34;n*2*pi&#34; units, so that frequency is in Hertz
    phi : float (0.24)
        Phase translation of modulation
    temp_ext : int
        Number of temp_res units to evaluate filter for.
        time array will be np.arange(0, temp_ext, temp_res)
    temp_ext_n_tau : Boolean
        Substitute temp_ext with a multiple of time constant (tau)
        temp_ext = temp_ext_n_tau * tau
        Approx &gt;=10 time constants of evaluation is appropriate.
        Below 10, the integral or sum diminishes nonnegligibly.
        Time constant dynamics are similar to ordinary negative exponential
        but slower: see Notes.


    Notes
    ----
    Taken from Teich and Qian (2006) and Chen et al (2001)[0]

    On time constant and decay/growth dynamics for this filter:

    $$ \begin{aligned}
        F(t)|^{n\tau}_{0} &amp;= -\frac{\tau+n\tau}{\tau}exp(\frac{-n\tau}{\tau})
        - (-)\frac{\tau}{\tau}\exp(\frac{0}{\tau}) \\
                                            &amp;= -(1+n)exp(-n) + 1 \\
                                            &amp;= 1 - \frac{1+n}{e^n} \\
                                            &amp;= 1 - \frac{1}{e^n} - \frac{n}{e^n}
    \end{aligned} $$
    &#34;&#34;&#34;

    # not sure if scaling extent by tau works for gamma as does negative exp?
    if temp_ext_n_tau:
        temp_ext = tau * temp_ext_n_tau

    # converting to seconds from milliseconds
    # parameters of teich and qian function are in seconds
    t = np.arange(0, temp_ext, temp_res) / 1000
    tau /= 1000

    # Note correction from teich and qian (apparent in Kuhlman as well as Chen(?) too)
    tf = (t / tau**2) * np.exp(-t / tau) * np.cos((w * t) + phi)

    if return_t:
        return tf, t
    else:
        return tf


def mk_sinstim(
        ori=90, spat_freq=1, temp_freq=1,
        spat_ext=120, temp_ext=1000,
        spat_res=1, temp_res=1):
    &#39;&#39;&#39;Generate sinusoidal grating

    Parameters
    ----

    ori : float (degrees)
    spat_freq : float
        spatial frequency of the sinusoidal grating in cycles/degree
    temp_freq : float
        temporal frequency in cycles per second
        how many cycles are traversed in one second of time
        how many cycles actually traversed in output depends on temp_ext also
    spat_ext, temp_ext, spat_res, temp_res : float
        passed to mk_coords


    Unit conversions, from base of min of arc and milliSecs to requisite degrees-&gt; radians
    and milliseconds -&gt; seconds is done within this function.
    BIG PRESUMPTION here (important!) is that all units coming from the mk_coords func
    are in minutes and milliSecs and so need to be converted for trigonometric functions
    used here.

    &#39;&#39;&#39;

    # Orientation to radians
    # add 90 so 0degs -&gt; 3-o&#39;clock, 90degs -&gt; 12-o&#39;clock
    # depends on how scaling is done below
    ori = np.radians(ori + 90)

    # Spatial Frequency
    # multiply by 2pi to change to whole cycles per unit
    k = spat_freq * 2 * np.pi  # 1 cpd (?)

    # X &amp; Y scaling factors to incorporate orientation
    # scale x coords by cos so constant at 90 degs (at which cos=0)
    # scale y coords by sin so constant at 0 degs (at chich sin=0)
    # then, as ori += 90, image rotated
    # Movement through time (tc) is in +90degs direction,
    # as coords are centered on zero and negative in bottom and left
    # and tc coords are subtracted below
    kx = k * np.cos(ori)
    ky = k * np.sin(ori)

    # Temporal Frequency
    # again, multiply by 2pi to be cycles per unit time
    omega = temp_freq * 2 * np.pi

    # creating coords
    xc, yc, tc = mk_coords(
        spat_ext=spat_ext, temp_ext=temp_ext,
        spat_res=spat_res, temp_res=temp_res
    )

    # Convert spatial coords to degs (from minutes)
    # Convert temporal coords to secs (from milliSecs)
    # scale coords so that unit -&gt; spat_freq, temp_freq cycles
    xc = kx * (xc / 60)
    yc = ky * (yc / 60)
    tc = omega * tc / 1000

    img = 0.5 + 0.5 * np.cos(xc + yc - tc)

    return img


def mk_barstim(
        height=None, width=None, speed=None, sweep=None,
        mean_lum=0.5, bar_lum=1, max_contrast=False,
        spat_ext=120, temp_ext=1000,
        spat_res=1, temp_res=1):
    &#39;&#39;&#39;
    Spatial and temporal units are all in minutes and milliSecs

    speed must be in minutes / milliSec (convert from deg/S by *60/1000)

    mean_lum : float (0-1)
        background value of returned image ... the mean luminance
        of the stimulus.
        Must be between zero (0) and one (1)
    bar_lum : float (0-1)
        value of the bar stimulus between 0 and 1
    max_contrast : boolean
        whether to always use maximum contrast for the background
        and ignore mean_lum.  ie, if bar_lum is 1, background is 0
        and vice versa.
    spat_ext, temp_ext, spat_res, temp_res : float
        passed to mk_coords
    &#39;&#39;&#39;

    # creating stim_space (y,x,t)
    stim_space = mk_coords(
        blank_grid=True,
        spat_ext=spat_ext, temp_ext=temp_ext,
        spat_res=spat_res, temp_res=temp_res
    )

    if max_contrast:
        # pick whichever of (0,1) is furtherest away from bar lum
        mean_lum = 1 if bar_lum &lt; 0.5 else 0

    stim_space += mean_lum

    # Round, convert to minutes and ensure odd so that always has a center
    height = round(height)
    if height % 2 == 0:
        height += 1

    width = round(width)
    if width % 2 == 0:
        width += 1

    sweep = round(sweep)
    if sweep % 2 == 0:
        sweep += 1

    img_rad = (stim_space.shape[0] - 1) / 2  # also idx of cent
    h_rad = (height - 1) / 2  # also idx of cent
    w_rad = int((width - 1) / 2)
    sweep_rad = (sweep - 1) / 2

    h_bounds = np.array([img_rad - h_rad, img_rad + h_rad]).astype(&#39;int&#39;)
    sweep_bounds = np.array([img_rad - sweep_rad, img_rad + sweep_rad]).astype(&#39;int&#39;)

    # milliSecs per minute of movement
    movement_stop = 1 / speed  # mS / min

    n_movement_stops = sweep
    time_needed = movement_stop * n_movement_stops

    assert stim_space.shape[2] &gt; time_needed, (
        f&#39;Time required for sweep {sweep} is {time_needed},&#39;
        f&#39;which is more than total stim time {stim_space.shape[2]}&#39;
    )

    # sweep + 1 , endpoint=True : purpose is to have, for every time_stop or frame, it&#39;s start and end
    # the +1 for sweep ensures that the first and second time_stops (idx 0,1) code the beg and end time for which
    # the bar is in the first position or minute.
    # second and third (idx 1,2) code beg and end time for time in second position / m inute
    # idx -2,-1 (second last and last) code time in last minute
    time_stops = np.linspace(0, time_needed, sweep + 1, endpoint=True).round().astype(&#39;int&#39;)

    # will have length of time_stops - 1 (due to time frame bracketing ... see above)
    sweep_stops = np.arange(sweep_bounds[0], sweep_bounds[1] + 1).astype(&#39;int&#39;)

    for t_idx in range(time_stops.size - 1):

        sweep_loc = sweep_stops[t_idx]
        time_beg, time_end = time_stops[[t_idx, t_idx + 1]]

        stim_space[
            h_bounds[0]: h_bounds[1] + 1,  # y
            sweep_loc - w_rad: sweep_loc + w_rad + 1,  # x
            time_beg: time_end
        ] = bar_lum

    return stim_space


def view_stim(stim, axes={&#39;y&#39;: 0, &#39;x&#39;: 1, &#39;t&#39;: 2}, xvals=None):
    #     if time_axis == 2:
    #         stim = stim.swapaxes(0,2).swapaxes(1,2)
    #     if time_axis == 1:
    #         stim = stim.swapaxes(0,1)

    if not xvals:
        xvals = np.arange(stim.shape[axes[&#39;t&#39;]])
    pg.image(stim, xvals=xvals, axes=axes)
    QtGui.QApplication.instance().exec_()


def mk_rf_spat_charact(rf, spat_freq, temp_freq, temp_res=10):
    &#39;&#39;&#39;Characterise response properties of RF by simple prod with sin grating

    Parameters
    ----
    rf : receptive field, output of mkRF
    spat_freq : spatial frequency of stimulus
        Passed to `spat_freq` arg of `mk_sinstim`
    temp_freq : temporal frequency of stimulus
        Passed to `temp_freq` arg of `mk_sinstim`
    temp_res : temporal resolution of stimulus
        Passed to `temp_res` of `mk_sinstim`


    Returns
    ----
    resp : array (1D)
        response of RF over temporal dimension of stimulusS
    resp_off : array (1D)
        Like resp, but inverted and translated by sum of rf
    stim : array (1D)
        Stimulus used ot generate response
        Output of mk_sinstim using spat_freq and temp_freq
    &#39;&#39;&#39;

    shape = rf.shape[0]
    # cent = shape//2

    stim = mk_sinstim(temp_freq=temp_freq, spat_freq=spat_freq, spat_ext=shape, temp_res=temp_res)

    rft = rf[..., np.newaxis] * np.ones(stim.shape[-1])

    resp = (rft * stim).sum(axis=(0, 1))
    resp_off = (-rft * stim).sum(axis=(0, 1)) + rf.sum()

    return resp, resp_off, stim


def plot_rf_spat_charact(rf, resp, resp_off, stim, figsize=(20, 7)):
    &#34;&#34;&#34;Plot characterisation of rf resp

    Takes output/args of mk_rf_spat_charact

    Produces 3 subplots:

    * Stim as 1D slice
    * RF resp (putatively ON)
    * RF OFF resp (presuming RF is on)
    &#34;&#34;&#34;

    shape = rf.shape[0]
    cent = shape // 2

    min_val, max_val = resp.min(), resp.max()
    min_val_off, max_val_off = resp_off.min(), resp_off.max()

    plt.figure(figsize=figsize)

    plt.subplot(1, 3, 1)
    plt.plot(stim[cent, cent, :])
    plt.title(&#39;stim&#39;)

    plt.subplot(1, 3, 2)
    plt.plot(resp)
    plt.axhline(min_val, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline(max_val, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline((max_val + min_val) / 2, ls=&#39;:&#39;, c=&#39;k&#39;)

    plt.title(f&#39;sum: {rf.sum().round(4)}, offset: {np.mean([min_val, max_val]).round(4)}&#39;)

    plt.subplot(1, 3, 3)

    plt.plot(resp_off)
    plt.axhline(min_val_off, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline(max_val_off, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline((max_val_off + min_val_off) / 2, ls=&#39;:&#39;, c=&#39;k&#39;)

    plt.title(f&#39;OFF sum: {rf.sum().round(4)}, offset: {np.mean([min_val_off, max_val_off]).round(4)}&#39;)

    plt.tight_layout()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lif.rf_stim.mk_barstim"><code class="name flex">
<span>def <span class="ident">mk_barstim</span></span>(<span>height=None, width=None, speed=None, sweep=None, mean_lum=0.5, bar_lum=1, max_contrast=False, spat_ext=120, temp_ext=1000, spat_res=1, temp_res=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Spatial and temporal units are all in minutes and milliSecs</p>
<p>speed must be in minutes / milliSec (convert from deg/S by *60/1000)</p>
<p>mean_lum : float (0-1)
background value of returned image &hellip; the mean luminance
of the stimulus.
Must be between zero (0) and one (1)
bar_lum : float (0-1)
value of the bar stimulus between 0 and 1
max_contrast : boolean
whether to always use maximum contrast for the background
and ignore mean_lum.
ie, if bar_lum is 1, background is 0
and vice versa.
spat_ext, temp_ext, spat_res, temp_res : float
passed to mk_coords</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_barstim(
        height=None, width=None, speed=None, sweep=None,
        mean_lum=0.5, bar_lum=1, max_contrast=False,
        spat_ext=120, temp_ext=1000,
        spat_res=1, temp_res=1):
    &#39;&#39;&#39;
    Spatial and temporal units are all in minutes and milliSecs

    speed must be in minutes / milliSec (convert from deg/S by *60/1000)

    mean_lum : float (0-1)
        background value of returned image ... the mean luminance
        of the stimulus.
        Must be between zero (0) and one (1)
    bar_lum : float (0-1)
        value of the bar stimulus between 0 and 1
    max_contrast : boolean
        whether to always use maximum contrast for the background
        and ignore mean_lum.  ie, if bar_lum is 1, background is 0
        and vice versa.
    spat_ext, temp_ext, spat_res, temp_res : float
        passed to mk_coords
    &#39;&#39;&#39;

    # creating stim_space (y,x,t)
    stim_space = mk_coords(
        blank_grid=True,
        spat_ext=spat_ext, temp_ext=temp_ext,
        spat_res=spat_res, temp_res=temp_res
    )

    if max_contrast:
        # pick whichever of (0,1) is furtherest away from bar lum
        mean_lum = 1 if bar_lum &lt; 0.5 else 0

    stim_space += mean_lum

    # Round, convert to minutes and ensure odd so that always has a center
    height = round(height)
    if height % 2 == 0:
        height += 1

    width = round(width)
    if width % 2 == 0:
        width += 1

    sweep = round(sweep)
    if sweep % 2 == 0:
        sweep += 1

    img_rad = (stim_space.shape[0] - 1) / 2  # also idx of cent
    h_rad = (height - 1) / 2  # also idx of cent
    w_rad = int((width - 1) / 2)
    sweep_rad = (sweep - 1) / 2

    h_bounds = np.array([img_rad - h_rad, img_rad + h_rad]).astype(&#39;int&#39;)
    sweep_bounds = np.array([img_rad - sweep_rad, img_rad + sweep_rad]).astype(&#39;int&#39;)

    # milliSecs per minute of movement
    movement_stop = 1 / speed  # mS / min

    n_movement_stops = sweep
    time_needed = movement_stop * n_movement_stops

    assert stim_space.shape[2] &gt; time_needed, (
        f&#39;Time required for sweep {sweep} is {time_needed},&#39;
        f&#39;which is more than total stim time {stim_space.shape[2]}&#39;
    )

    # sweep + 1 , endpoint=True : purpose is to have, for every time_stop or frame, it&#39;s start and end
    # the +1 for sweep ensures that the first and second time_stops (idx 0,1) code the beg and end time for which
    # the bar is in the first position or minute.
    # second and third (idx 1,2) code beg and end time for time in second position / m inute
    # idx -2,-1 (second last and last) code time in last minute
    time_stops = np.linspace(0, time_needed, sweep + 1, endpoint=True).round().astype(&#39;int&#39;)

    # will have length of time_stops - 1 (due to time frame bracketing ... see above)
    sweep_stops = np.arange(sweep_bounds[0], sweep_bounds[1] + 1).astype(&#39;int&#39;)

    for t_idx in range(time_stops.size - 1):

        sweep_loc = sweep_stops[t_idx]
        time_beg, time_end = time_stops[[t_idx, t_idx + 1]]

        stim_space[
            h_bounds[0]: h_bounds[1] + 1,  # y
            sweep_loc - w_rad: sweep_loc + w_rad + 1,  # x
            time_beg: time_end
        ] = bar_lum

    return stim_space</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_coords"><code class="name flex">
<span>def <span class="ident">mk_coords</span></span>(<span>spat_res=1, temp_res=1, spat_ext=300, temp_ext=1000, temp_dim=True, blank_grid=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces spatial and temporal coordinates (ie meshgrid) for
generating RFs and stimuli
Base units are minutes of arc and milliSeconds</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spat_res</code></strong> :&ensp;<code>float</code></dt>
<dd>resolution, in minutes of arc, of meshgrid</dd>
<dt><strong><code>temp_res</code></strong> :&ensp;<code>float</code></dt>
<dd>resolution, in milliseconds, of temporal dimension of meshgrid</dd>
<dt><strong><code>spat_ext</code></strong> :&ensp;<code>int</code></dt>
<dd>Width and height, in minutes of arc, of spatial dimensions of meshgrid
spat_ext is the total width (horiztontal or vertical) of the stimulus
image generated.
radial extent (horizontal or vertical, from center) will be
floor(spat_ext/2), and always centred on zero.
So actual extent will be 1*spat_res greater for even and as specified
for odd extents</dd>
<dt><strong><code>temp_ext</code></strong> :&ensp;<code>int</code></dt>
<dd>duration, in milliseconds, of temporal dimension</dd>
<dt><strong><code>temp_dim</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to include a temporal dimension in the meshgrid</dd>
<dt><strong><code>blank_grid</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to return a meshhgrid with all values being zero
Useful for filling in the grid manually for stimulus creation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xc, yc, tc (if temp_dim)</code></dt>
<dd>&nbsp;</dd>
<dt><code>xc, yc if temp_dim==false</code></dt>
<dd>&nbsp;</dd>
<dt><code>all meshgrids filled with appropriate coordinate values</code></dt>
<dd>&nbsp;</dd>
<dt><code>If blank_grid, then single meshgrid (3D: x,y,t)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_coords(
        spat_res=1, temp_res=1,
        spat_ext=300, temp_ext=1000,
        temp_dim=True, blank_grid=False):
    &#39;&#39;&#39;
    Produces spatial and temporal coordinates (ie meshgrid) for
    generating RFs and stimuli
    Base units are minutes of arc and milliSeconds

    Parameters
    ----
    spat_res : float
        resolution, in minutes of arc, of meshgrid
    temp_res : float
        resolution, in milliseconds, of temporal dimension of meshgrid
    spat_ext : int
        Width and height, in minutes of arc, of spatial dimensions of meshgrid
        spat_ext is the total width (horiztontal or vertical) of the stimulus
        image generated.
        radial extent (horizontal or vertical, from center) will be
        floor(spat_ext/2), and always centred on zero.
        So actual extent will be 1*spat_res greater for even and as specified
        for odd extents
    temp_ext : int
        duration, in milliseconds, of temporal dimension
    temp_dim : boolean
        Whether to include a temporal dimension in the meshgrid
    blank_grid : boolean
        Whether to return a meshhgrid with all values being zero
        Useful for filling in the grid manually for stimulus creation

    Returns
    ----
    xc, yc, tc (if temp_dim)
    xc, yc if temp_dim==false

    all meshgrids filled with appropriate coordinate values
    If blank_grid, then single meshgrid (3D: x,y,t)
    &#39;&#39;&#39;

    spat_radius = np.floor(spat_ext / 2)
    x_coords = np.arange(-spat_radius, spat_radius + spat_res, spat_res)
    # treat as image (with origin at top left or upper)
    # y_cords positive at top and negative at bottom
    y_coords = x_coords[::-1]

    t_coords = np.arange(0, temp_ext, temp_res)

    # ie, one array with appropriate size, each coordinate represented by a single value
    if blank_grid:
        space = np.zeros((y_coords.size, x_coords.size, t_coords.size))
        return space

    if not temp_dim:
        xc, yc = np.meshgrid(x_coords, y_coords)
        return xc, yc
    else:
        xc, yc, tc = np.meshgrid(x_coords, y_coords, t_coords)
        return xc, yc, tc</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_rf"><code class="name flex">
<span>def <span class="ident">mk_rf</span></span>(<span>spat_res=1, cent_h_sd=10.6, cent_v_sd=10.6, surr_h_sd=31.8, surr_v_sd=31.8, mag_cent=1, mag_surr=1, rf_sd_limit=5, return_cent_surr=False, return_coords=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate DoG Rec Field</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spat_res</code></strong> :&ensp;<code>float</code></dt>
<dd>resolution of meshgrid used to create RF
passed to mk_coords</dd>
<dt>cent/surr_h/v_sd : float</dt>
<dt>standard dev of gaussian used to generate RF</dt>
<dt>cent/surr -&gt; center or surround component</dt>
<dt>h/v : vertical or horizontal axis</dt>
<dt>mag_cent/surr : float</dt>
<dt>absolute magnitude of cent/surr component</dt>
<dt><strong><code>rf_sd_limit</code></strong> :&ensp;<code>float</code></dt>
<dd>span of underlying mesdhgrid in number of standard deviations
the maximum of of all cent/surr_h/v_sd are used
important to ensure that the sum of the surround is not arbitrarily
trunacated</dd>
<dt><strong><code>return_cent_surr</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether to return the center and surround components also</dd>
<dt><strong><code>return_coords</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether to also return the meshgrid for x and y</dd>
</dl>
<p>Units are defined in arc minutes</p>
<p>Current defaults from Woergoetter and Koch (1991)</p>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_rf(
        spat_res=1,
        cent_h_sd=10.6, cent_v_sd=10.6, surr_h_sd=31.8, surr_v_sd=31.8,
        mag_cent=1, mag_surr=1,
        rf_sd_limit=5,
        return_cent_surr=False, return_coords=False):
    &#39;&#39;&#39;Generate DoG Rec Field

    Parameters
    ----
    spat_res : float
        resolution of meshgrid used to create RF
        passed to mk_coords
    cent/surr_h/v_sd : float
        standard dev of gaussian used to generate RF
        cent/surr -&gt; center or surround component
        h/v : vertical or horizontal axis
    mag_cent/surr : float
        absolute magnitude of cent/surr component
    rf_sd_limit : float
        span of underlying mesdhgrid in number of standard deviations
        the maximum of of all cent/surr_h/v_sd are used
        important to ensure that the sum of the surround is not arbitrarily
        trunacated
    return_cent_surr : boolean
        whether to return the center and surround components also
    return_coords : boolean
        whether to also return the meshgrid for x and y

    Units are defined in arc minutes

    Current defaults from Woergoetter and Koch (1991)

    Returns
    ----

    &#39;&#39;&#39;

    # integer rounded max sd times rf_sd_limit -&gt; img limit for RF
    max_sd = rf_sd_limit * np.ceil(
        np.max([cent_h_sd, cent_v_sd, surr_h_sd, surr_v_sd])
    )
    # spatial extent (for mk_coords)
    # add 1 to ensure number is odd so size of mk_coords output is as specified
    spat_ext = (2 * max_sd) + 1

    # only one coords necessary, as square/cartesion grid (how to noise hexagonal centering?)
    x_coords, y_coords = mk_coords(spat_res=spat_res, spat_ext=spat_ext, temp_dim=False)

    rf_cent = (
        # mag divide by normalising factor with both sds (equivalent to sq if they were identical)
        (mag_cent / (2 * np.pi * cent_v_sd * cent_h_sd)) *
        np.exp(
            - (
                (x_coords**2 / (2 * cent_h_sd**2)) +
                (y_coords**2 / (2 * cent_v_sd**2))
            )
        )
    )

    rf_surr = (
        (mag_surr / (2 * np.pi * surr_v_sd * surr_h_sd)) *
        np.exp(
            - (
                (x_coords**2 / (2 * surr_h_sd**2)) +
                (y_coords**2 / (2 * surr_v_sd**2))
            )
        )
    )

    rf = rf_cent - rf_surr

    if not (return_cent_surr or return_coords):

        return rf

    else:
        ret_vars = (rf,)

        if return_cent_surr:
            ret_vars += rf_cent, rf_surr
        if return_coords:
            ret_vars += x_coords, y_coords

        return ret_vars</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_rf_spat_charact"><code class="name flex">
<span>def <span class="ident">mk_rf_spat_charact</span></span>(<span>rf, spat_freq, temp_freq, temp_res=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Characterise response properties of RF by simple prod with sin grating</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rf</code></strong> :&ensp;<code>receptive field, output</code> of <code>mkRF</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spat_freq</code></strong> :&ensp;<code>spatial frequency</code> of <code>stimulus</code></dt>
<dd>Passed to <code>spat_freq</code> arg of <code><a title="lif.rf_stim.mk_sinstim" href="#lif.rf_stim.mk_sinstim">mk_sinstim()</a></code></dd>
<dt><strong><code>temp_freq</code></strong> :&ensp;<code>temporal frequency</code> of <code>stimulus</code></dt>
<dd>Passed to <code>temp_freq</code> arg of <code><a title="lif.rf_stim.mk_sinstim" href="#lif.rf_stim.mk_sinstim">mk_sinstim()</a></code></dd>
<dt><strong><code>temp_res</code></strong> :&ensp;<code>temporal resolution</code> of <code>stimulus</code></dt>
<dd>Passed to <code>temp_res</code> of <code><a title="lif.rf_stim.mk_sinstim" href="#lif.rf_stim.mk_sinstim">mk_sinstim()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>resp</code></strong> :&ensp;<code>array (1D)</code></dt>
<dd>response of RF over temporal dimension of stimulusS</dd>
<dt><strong><code>resp_off</code></strong> :&ensp;<code>array (1D)</code></dt>
<dd>Like resp, but inverted and translated by sum of rf</dd>
<dt><strong><code>stim</code></strong> :&ensp;<code>array (1D)</code></dt>
<dd>Stimulus used ot generate response
Output of mk_sinstim using spat_freq and temp_freq</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_rf_spat_charact(rf, spat_freq, temp_freq, temp_res=10):
    &#39;&#39;&#39;Characterise response properties of RF by simple prod with sin grating

    Parameters
    ----
    rf : receptive field, output of mkRF
    spat_freq : spatial frequency of stimulus
        Passed to `spat_freq` arg of `mk_sinstim`
    temp_freq : temporal frequency of stimulus
        Passed to `temp_freq` arg of `mk_sinstim`
    temp_res : temporal resolution of stimulus
        Passed to `temp_res` of `mk_sinstim`


    Returns
    ----
    resp : array (1D)
        response of RF over temporal dimension of stimulusS
    resp_off : array (1D)
        Like resp, but inverted and translated by sum of rf
    stim : array (1D)
        Stimulus used ot generate response
        Output of mk_sinstim using spat_freq and temp_freq
    &#39;&#39;&#39;

    shape = rf.shape[0]
    # cent = shape//2

    stim = mk_sinstim(temp_freq=temp_freq, spat_freq=spat_freq, spat_ext=shape, temp_res=temp_res)

    rft = rf[..., np.newaxis] * np.ones(stim.shape[-1])

    resp = (rft * stim).sum(axis=(0, 1))
    resp_off = (-rft * stim).sum(axis=(0, 1)) + rf.sum()

    return resp, resp_off, stim</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_sinstim"><code class="name flex">
<span>def <span class="ident">mk_sinstim</span></span>(<span>ori=90, spat_freq=1, temp_freq=1, spat_ext=120, temp_ext=1000, spat_res=1, temp_res=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate sinusoidal grating</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ori</code></strong> :&ensp;<code>float (degrees)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spat_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>spatial frequency of the sinusoidal grating in cycles/degree</dd>
<dt><strong><code>temp_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>temporal frequency in cycles per second
how many cycles are traversed in one second of time
how many cycles actually traversed in output depends on temp_ext also</dd>
<dt><strong><code>spat_ext</code></strong>, <strong><code>temp_ext</code></strong>, <strong><code>spat_res</code></strong>, <strong><code>temp_res</code></strong> :&ensp;<code>float</code></dt>
<dd>passed to mk_coords</dd>
</dl>
<p>Unit conversions, from base of min of arc and milliSecs to requisite degrees-&gt; radians
and milliseconds -&gt; seconds is done within this function.
BIG PRESUMPTION here (important!) is that all units coming from the mk_coords func
are in minutes and milliSecs and so need to be converted for trigonometric functions
used here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_sinstim(
        ori=90, spat_freq=1, temp_freq=1,
        spat_ext=120, temp_ext=1000,
        spat_res=1, temp_res=1):
    &#39;&#39;&#39;Generate sinusoidal grating

    Parameters
    ----

    ori : float (degrees)
    spat_freq : float
        spatial frequency of the sinusoidal grating in cycles/degree
    temp_freq : float
        temporal frequency in cycles per second
        how many cycles are traversed in one second of time
        how many cycles actually traversed in output depends on temp_ext also
    spat_ext, temp_ext, spat_res, temp_res : float
        passed to mk_coords


    Unit conversions, from base of min of arc and milliSecs to requisite degrees-&gt; radians
    and milliseconds -&gt; seconds is done within this function.
    BIG PRESUMPTION here (important!) is that all units coming from the mk_coords func
    are in minutes and milliSecs and so need to be converted for trigonometric functions
    used here.

    &#39;&#39;&#39;

    # Orientation to radians
    # add 90 so 0degs -&gt; 3-o&#39;clock, 90degs -&gt; 12-o&#39;clock
    # depends on how scaling is done below
    ori = np.radians(ori + 90)

    # Spatial Frequency
    # multiply by 2pi to change to whole cycles per unit
    k = spat_freq * 2 * np.pi  # 1 cpd (?)

    # X &amp; Y scaling factors to incorporate orientation
    # scale x coords by cos so constant at 90 degs (at which cos=0)
    # scale y coords by sin so constant at 0 degs (at chich sin=0)
    # then, as ori += 90, image rotated
    # Movement through time (tc) is in +90degs direction,
    # as coords are centered on zero and negative in bottom and left
    # and tc coords are subtracted below
    kx = k * np.cos(ori)
    ky = k * np.sin(ori)

    # Temporal Frequency
    # again, multiply by 2pi to be cycles per unit time
    omega = temp_freq * 2 * np.pi

    # creating coords
    xc, yc, tc = mk_coords(
        spat_ext=spat_ext, temp_ext=temp_ext,
        spat_res=spat_res, temp_res=temp_res
    )

    # Convert spatial coords to degs (from minutes)
    # Convert temporal coords to secs (from milliSecs)
    # scale coords so that unit -&gt; spat_freq, temp_freq cycles
    xc = kx * (xc / 60)
    yc = ky * (yc / 60)
    tc = omega * tc / 1000

    img = 0.5 + 0.5 * np.cos(xc + yc - tc)

    return img</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_tempfilt"><code class="name flex">
<span>def <span class="ident">mk_tempfilt</span></span>(<span>tau=10, temp_ext=100, temp_res=1, temp_ext_n_tau=None, return_t=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a temporal filter</p>
<p>All time parameters in milliseconds</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tau</code></strong> :&ensp;<code>float</code></dt>
<dd>Time constant</dd>
<dt><strong><code>temp_ext</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of temporal filter</dd>
<dt><strong><code>temp_res</code></strong> :&ensp;<code>float</code></dt>
<dd>resolution of temporal filter
size of temporal increment in milliseconds</dd>
<dt><strong><code>temp_ext_n_tau</code></strong> :&ensp;<code>int (Default None)</code></dt>
<dd>length of temporl filter but in number of tau (time constants)
If None, temp_ext used instead, if int, this is used</dd>
<dt><strong><code>return_t</code></strong> :&ensp;<code>Boolean</code></dt>
<dd>If True, return time units array as well as magnitude of filer
Else, return just the filter</dd>
</dl>
<p>Maths and values taken from worgotter and koch (1991)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_tempfilt(tau=10, temp_ext=100, temp_res=1, temp_ext_n_tau=None, return_t=False):
    &#39;&#39;&#39;Generate a temporal filter

    All time parameters in milliseconds

    Parameters
    ----
    tau : float
        Time constant
    temp_ext : float
        Length of temporal filter
    temp_res : float
        resolution of temporal filter
        size of temporal increment in milliseconds
    temp_ext_n_tau : int (Default None)
        length of temporl filter but in number of tau (time constants)
        If None, temp_ext used instead, if int, this is used
    return_t : Boolean
        If True, return time units array as well as magnitude of filer
        Else, return just the filter

    Maths and values taken from worgotter and koch (1991)
    &#39;&#39;&#39;

    # Use number of time consts as measure of temp extend, if specified
    if temp_ext_n_tau:
        temp_ext = temp_ext_n_tau * tau

    t = np.arange(0, temp_ext, temp_res)
    tf = np.exp(-t / tau) / tau

    if return_t:
        return t, tf
    else:
        return tf</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_tempfilt2"><code class="name flex">
<span>def <span class="ident">mk_tempfilt2</span></span>(<span>tau1=10, tau2=20, temp_res=1, temp_ext_n_tau=5, return_t=True, correct_integral_errors=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate two temporal filters with different time constants</p>
<p>As with mk_tempfilt but with two taus</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>correct_integral_errors</code></strong> :&ensp;<code>Boolean</code></dt>
<dd>Ensure that both temporal filters sum to 1
Necessary due to discretisation errors and need
to ensure both filters do not alter the magnitude of the
input signal.
Done by dividing the temporal filter by the sum of the filter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tf1</code></strong>, <strong><code>tf2</code></strong> :&ensp;<code>array (1D)</code></dt>
<dd>EAch as the output of mk_tempfilt
Magnitude of the filter at each time step in 1D filter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_tempfilt2(
        tau1=10, tau2=20,
        temp_res=1, temp_ext_n_tau=5, return_t=True,
        correct_integral_errors=True):
    &#34;&#34;&#34;Generate two temporal filters with different time constants

    As with mk_tempfilt but with two taus


    Parameters
    ----
    correct_integral_errors : Boolean
        Ensure that both temporal filters sum to 1
        Necessary due to discretisation errors and need
        to ensure both filters do not alter the magnitude of the
        input signal.
        Done by dividing the temporal filter by the sum of the filter

    Returns
    ----
    tf1, tf2 : array (1D)
        EAch as the output of mk_tempfilt
        Magnitude of the filter at each time step in 1D filter
    &#34;&#34;&#34;

    temp_ext = max([tau1, tau2]) * temp_ext_n_tau
    t, tf1 = mk_tempfilt(tau1, temp_ext, temp_res=temp_res, return_t=True)
    tf2 = mk_tempfilt(tau2, temp_ext, temp_res=temp_res)

    if correct_integral_errors:
        tf1 /= tf1.sum()
        tf2 /= tf2.sum()

    if return_t:
        return t, tf1, tf2
    else:
        return tf1, tf2</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.mk_tqtempfilt"><code class="name flex">
<span>def <span class="ident">mk_tqtempfilt</span></span>(<span>tau=16, w=25.132741228718345, phi=0.24, temp_ext=100, temp_ext_n_tau=None, temp_res=1, return_t=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate single temp filter by modulating a negative exp with a cosine</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tau</code></strong> :&ensp;<code>float (milliseconds)</code></dt>
<dd>Time constant of negative exponential</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float (n*2*pi radians)</code></dt>
<dd>Frequency of modulation of negative exp
As in "n<em>2</em>pi" units, so that frequency is in Hertz</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float (0.24)</code></dt>
<dd>Phase translation of modulation</dd>
<dt><strong><code>temp_ext</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of temp_res units to evaluate filter for.
time array will be np.arange(0, temp_ext, temp_res)</dd>
<dt><strong><code>temp_ext_n_tau</code></strong> :&ensp;<code>Boolean</code></dt>
<dd>Substitute temp_ext with a multiple of time constant (tau)
temp_ext = temp_ext_n_tau * tau
Approx &gt;=10 time constants of evaluation is appropriate.
Below 10, the integral or sum diminishes nonnegligibly.
Time constant dynamics are similar to ordinary negative exponential
but slower: see Notes.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Taken from Teich and Qian (2006) and Chen et al (2001)[0]</p>
<p>On time constant and decay/growth dynamics for this filter:</p>
<p><span><span class="MathJax_Preview"> \begin{aligned}
F(t)|^{n\tau}_{0} &amp;= -\frac{\tau+n\tau}{\tau}exp(\frac{-n\tau}{\tau})
- (-)\frac{\tau}{\tau}\exp(\frac{0}{\tau}) \\
&amp;= -(1+n)exp(-n) + 1 \\
&amp;= 1 - \frac{1+n}{e^n} \\
&amp;= 1 - \frac{1}{e^n} - \frac{n}{e^n}
\end{aligned} </span><script type="math/tex; mode=display"> \begin{aligned}
F(t)|^{n\tau}_{0} &= -\frac{\tau+n\tau}{\tau}exp(\frac{-n\tau}{\tau})
- (-)\frac{\tau}{\tau}\exp(\frac{0}{\tau}) \\
&= -(1+n)exp(-n) + 1 \\
&= 1 - \frac{1+n}{e^n} \\
&= 1 - \frac{1}{e^n} - \frac{n}{e^n}
\end{aligned} </script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_tqtempfilt(
        tau=16, w=4 * 2 * np.pi, phi=0.24,
        temp_ext=100, temp_ext_n_tau=None,
        temp_res=1, return_t=True):
    r&#34;&#34;&#34;Generate single temp filter by modulating a negative exp with a cosine

    Parameters
    ----
    tau : float (milliseconds)
        Time constant of negative exponential
    w : float (n*2*pi radians)
        Frequency of modulation of negative exp
        As in &#34;n*2*pi&#34; units, so that frequency is in Hertz
    phi : float (0.24)
        Phase translation of modulation
    temp_ext : int
        Number of temp_res units to evaluate filter for.
        time array will be np.arange(0, temp_ext, temp_res)
    temp_ext_n_tau : Boolean
        Substitute temp_ext with a multiple of time constant (tau)
        temp_ext = temp_ext_n_tau * tau
        Approx &gt;=10 time constants of evaluation is appropriate.
        Below 10, the integral or sum diminishes nonnegligibly.
        Time constant dynamics are similar to ordinary negative exponential
        but slower: see Notes.


    Notes
    ----
    Taken from Teich and Qian (2006) and Chen et al (2001)[0]

    On time constant and decay/growth dynamics for this filter:

    $$ \begin{aligned}
        F(t)|^{n\tau}_{0} &amp;= -\frac{\tau+n\tau}{\tau}exp(\frac{-n\tau}{\tau})
        - (-)\frac{\tau}{\tau}\exp(\frac{0}{\tau}) \\
                                            &amp;= -(1+n)exp(-n) + 1 \\
                                            &amp;= 1 - \frac{1+n}{e^n} \\
                                            &amp;= 1 - \frac{1}{e^n} - \frac{n}{e^n}
    \end{aligned} $$
    &#34;&#34;&#34;

    # not sure if scaling extent by tau works for gamma as does negative exp?
    if temp_ext_n_tau:
        temp_ext = tau * temp_ext_n_tau

    # converting to seconds from milliseconds
    # parameters of teich and qian function are in seconds
    t = np.arange(0, temp_ext, temp_res) / 1000
    tau /= 1000

    # Note correction from teich and qian (apparent in Kuhlman as well as Chen(?) too)
    tf = (t / tau**2) * np.exp(-t / tau) * np.cos((w * t) + phi)

    if return_t:
        return tf, t
    else:
        return tf</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.plot_rf_spat_charact"><code class="name flex">
<span>def <span class="ident">plot_rf_spat_charact</span></span>(<span>rf, resp, resp_off, stim, figsize=(20, 7))</span>
</code></dt>
<dd>
<div class="desc"><p>Plot characterisation of rf resp</p>
<p>Takes output/args of mk_rf_spat_charact</p>
<p>Produces 3 subplots:</p>
<ul>
<li>Stim as 1D slice</li>
<li>RF resp (putatively ON)</li>
<li>RF OFF resp (presuming RF is on)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_rf_spat_charact(rf, resp, resp_off, stim, figsize=(20, 7)):
    &#34;&#34;&#34;Plot characterisation of rf resp

    Takes output/args of mk_rf_spat_charact

    Produces 3 subplots:

    * Stim as 1D slice
    * RF resp (putatively ON)
    * RF OFF resp (presuming RF is on)
    &#34;&#34;&#34;

    shape = rf.shape[0]
    cent = shape // 2

    min_val, max_val = resp.min(), resp.max()
    min_val_off, max_val_off = resp_off.min(), resp_off.max()

    plt.figure(figsize=figsize)

    plt.subplot(1, 3, 1)
    plt.plot(stim[cent, cent, :])
    plt.title(&#39;stim&#39;)

    plt.subplot(1, 3, 2)
    plt.plot(resp)
    plt.axhline(min_val, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline(max_val, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline((max_val + min_val) / 2, ls=&#39;:&#39;, c=&#39;k&#39;)

    plt.title(f&#39;sum: {rf.sum().round(4)}, offset: {np.mean([min_val, max_val]).round(4)}&#39;)

    plt.subplot(1, 3, 3)

    plt.plot(resp_off)
    plt.axhline(min_val_off, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline(max_val_off, ls=&#39;:&#39;, c=&#39;k&#39;)
    plt.axhline((max_val_off + min_val_off) / 2, ls=&#39;:&#39;, c=&#39;k&#39;)

    plt.title(f&#39;OFF sum: {rf.sum().round(4)}, offset: {np.mean([min_val_off, max_val_off]).round(4)}&#39;)

    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="lif.rf_stim.view_stim"><code class="name flex">
<span>def <span class="ident">view_stim</span></span>(<span>stim, axes={'y': 0, 'x': 1, 't': 2}, xvals=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_stim(stim, axes={&#39;y&#39;: 0, &#39;x&#39;: 1, &#39;t&#39;: 2}, xvals=None):
    #     if time_axis == 2:
    #         stim = stim.swapaxes(0,2).swapaxes(1,2)
    #     if time_axis == 1:
    #         stim = stim.swapaxes(0,1)

    if not xvals:
        xvals = np.arange(stim.shape[axes[&#39;t&#39;]])
    pg.image(stim, xvals=xvals, axes=axes)
    QtGui.QApplication.instance().exec_()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lif" href="index.html">lif</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lif.rf_stim.mk_barstim" href="#lif.rf_stim.mk_barstim">mk_barstim</a></code></li>
<li><code><a title="lif.rf_stim.mk_coords" href="#lif.rf_stim.mk_coords">mk_coords</a></code></li>
<li><code><a title="lif.rf_stim.mk_rf" href="#lif.rf_stim.mk_rf">mk_rf</a></code></li>
<li><code><a title="lif.rf_stim.mk_rf_spat_charact" href="#lif.rf_stim.mk_rf_spat_charact">mk_rf_spat_charact</a></code></li>
<li><code><a title="lif.rf_stim.mk_sinstim" href="#lif.rf_stim.mk_sinstim">mk_sinstim</a></code></li>
<li><code><a title="lif.rf_stim.mk_tempfilt" href="#lif.rf_stim.mk_tempfilt">mk_tempfilt</a></code></li>
<li><code><a title="lif.rf_stim.mk_tempfilt2" href="#lif.rf_stim.mk_tempfilt2">mk_tempfilt2</a></code></li>
<li><code><a title="lif.rf_stim.mk_tqtempfilt" href="#lif.rf_stim.mk_tqtempfilt">mk_tqtempfilt</a></code></li>
<li><code><a title="lif.rf_stim.plot_rf_spat_charact" href="#lif.rf_stim.plot_rf_spat_charact">plot_rf_spat_charact</a></code></li>
<li><code><a title="lif.rf_stim.view_stim" href="#lif.rf_stim.view_stim">view_stim</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>