<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>lif.lif_utils API documentation</title>
<meta name="description" content="Utilities for inspecting or understanding aspects of this modelling project" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lif.lif_utils</code></h1>
</header>
<section id="section-intro">
<p>Utilities for inspecting or understanding aspects of this modelling project</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utilities for inspecting or understanding aspects of this modelling project


&#34;&#34;&#34;

from functools import partial

import matplotlib.pyplot as plt
from numpy import fft
import numpy as np

from scipy.optimize import minimize

from ipywidgets import interact, fixed
# from ipywidgets import IntSlider, FloatSlider, interactive_output, HBox, VBox


# &gt; sinusoid and fft


def gen_sin(a, c, t, f=10):
    &#34;&#34;&#34;Generate sinusoid with t: 1-&gt;2pi

    Parameters
    ----
    a: amplitude
    c: translation
    t: time, in &#34;seconds&#34;, with a frequency of 1 corresponding
        to a single cycle in 1 second of t
    f: frequency
    &#34;&#34;&#34;

    return a * np.sin(f * 2 * np.pi * t) + c


def gen_fft(s, t, view_max=20):
    &#34;&#34;&#34;Generate fft spectrum and frequency axis

    Parameters
    ----
    s: signal
    t: time dimension over which signal modulates
    view_max: max number of frequency increments returned

    Returns
    ----
    spectrum:
        normalised by size of signal array and mirroring of real signals
        in imaginary and complex (ie, multiplied by 2)
        Magnitude of 0Hz is not multiplied though, as not mirrored

        absolute values returned

    freq:
        frequencies corresponding to spectrum values
    &#34;&#34;&#34;

    norm_factor = t.size

    spec = fft.rfft(s)
    # spec = fft.fftshift(fft.fft(s))
    spec[1:] *= 2 / norm_factor  # to normalise the split / coonjugate values
    spec[0] /= norm_factor
    spec = np.abs(spec)

    freq = fft.rfftfreq(t.size, (t[1] - t[0]))
    # freq = fft.fftfreq(t.size, (t[1]-t[0]))

    return spec[:view_max], freq[:view_max]


def gen_freq_report(n, d, print_rep=True):
    &#39;&#39;&#39;Reports description of freq range for a signal

    Should correspond with functions like `np.fft.rfftfreq`

    Parameters
    ----
    n : number of samples
    d : distance between samples (inverse of sample frequency)

    Returns
    ----
    min_freq, max_freq, num_freqs : float, float, int

    Notes
    ----
    min = 1 / (nd)
    If d = resolution and n = extent / resolution,
    then n * d = extent
    then min = 1 / extent

    step and min are the same

    max = 1 / (2d) if n is even
    max = (n-1) / (2dn) if n is odd

    n_freqs = floor(n / 2)
    &#39;&#39;&#39;

    min_freq = step_freq = 1 / (d * n)
    # depends on whether n is odd or even
    max_freq = 1 / (2 * d) if (n % 2 == 0) else (n - 1) / (2 * d * n)
    num_freqs = n // 2

    if print_rep:
        print(f&#34;&#34;&#34;
        min:  {min_freq:.3f}
        step: {step_freq:.3f}
        max:  {max_freq:.3f}
        num:  {num_freqs} (plus zero)
        &#34;&#34;&#34;)

    return min_freq, max_freq, num_freqs


# &gt;&gt; Rectification and FFt

def show_rect_wave_fft(a, c, t, view_max, figsize=(15, 8)):
    &#34;&#34;&#34;Graph effect of rectification on spectrum

    Parameters passed to gen_sin
    figsize -&gt; plt.figure

    First graph: signal
    Second graph: spectra

    Signals:
        Full
        rectified at zero (rect)
        centered and rectified at zero (r_sub)
    &#34;&#34;&#34;

    sin = gen_sin(a, c, t, f=10)

    sin_rect = sin.copy()
    sin_rect[sin_rect &lt; 0] = 0

    sin_r_sub = sin - c
    sin_r_sub[sin_r_sub &lt; 0] = 0

    spec, freq = gen_fft(sin, t, view_max=view_max)
    spec_rect, freq = gen_fft(sin_rect, t, view_max=view_max)

    spec_r_sub, freq = gen_fft(sin_r_sub, t, view_max=view_max)

    # mod ratio
    # 10 and 0, as with time window of 1000 and sample period of 1/1000, freq is in steps of 1
    sin_mr = spec[10] / spec[0]
    sin_rect_mr = spec_rect[10] / spec_rect[0]
    sin_r_sub_mr = spec_r_sub[10] / spec_r_sub[0]

    plt.figure(figsize=figsize)

    plt.subplot(121)
    plt.plot(sin, lw=2)
    plt.plot(sin_rect, &#39;:&#39;, lw=3)
    plt.plot(sin_r_sub, &#39;--&#39;, lw=3)

    plt.subplot(122)
    plt.plot(freq, spec)
    plt.plot(freq, spec_rect, label=&#39;rect&#39;)
    plt.plot(freq, spec_r_sub, label=&#39;r_sub&#39;)
    plt.legend()
    plt.title(f&#39;mr: sin: {sin_mr:.2f}, r: {sin_rect_mr:.2f}, r_sub: {sin_r_sub_mr:.2f}&#39;)


# &gt;&gt;&gt; Jupyter Dashboard
def gen_interactive_rect_fft(
        a=(0, 100, 1), c=(-5, 200, 0.1),
        view_max=(5, 100, 1),
        t=(0, 1, 1 / 1000),
        figsize=(15, 8)):
    &#34;&#34;&#34;Generate interactive ipywidget dashboard of rectified signal and fft

    Argments passed to show_rect_wave_fft

    t tuple is passed to numpy as np.arange(*t).
    Thus t: (start, stop, step)

    t and figsize are passed to interact as fixed arguments

    &#34;&#34;&#34;

    t = fixed(np.arange(*t))
    figsize = fixed(figsize)

    interact(show_rect_wave_fft, a=a, c=c, view_max=view_max, t=t, figsize=figsize)


# &gt; F1 Calculation

def gen_rect_sig_fft(a, c, t, f=1, view_max=20):
    &#34;&#34;&#34;generate rectified signal and spec for a(amp), c(trans) and t(time)&#34;&#34;&#34;

    signal = gen_sin(a, c, t, f=f)
    signal[signal &lt; 0] = 0  # rectify signal

    spec, freq = gen_fft(signal, t, view_max=view_max)

    return signal, spec, freq


def gen_f1_diff(a, c, t, f1, f=1):
    &#34;&#34;&#34;Find diff between target f1 and f1 of rectified sin

    a, c, t, f -&gt; gen_sin

    f1: target f1

    frequency (f) is vital to this process, as it is the frequency that defines
    the F1 of the signal.
    frequency must be set so that it is guaranteed to be available from the fft.

    To do this, f must be set to an integer (1 here), AND,
    the total length of t (in time) must be 1, which ensures that the number of
    samples (n) and their period (d) are inversions of each other (n = 1/d).
    This ensures that the frequencies available from the fft are:
    0, 1, 2, ..., n/2-1, n/2 (see docs for np.fft.rfftfreq)
    &#34;&#34;&#34;

    # signal = gen_sin(a, c, t, f=f)
    # signal[signal &lt; 0] = 0  # rectify signal

    # spec, freq = gen_fft(signal, t)

    signal, spec, freq = gen_rect_sig_fft(a, c, t, f)

    assert np.isclose((t[1] - t[0]) * t.size, 1), (
        &#39;t (time) must have time length 1 and d = 1/n \n&#39;,
        f&#39;Currently size (n): {t.size}, d: {t[1] - t[0]} and d*n: {t.size * (t[1]-t[0])}&#39;)

    assert isinstance(f, int), &#39;f must be an integer&#39;

    # this works as the freqs are 0, 1, 2 (provided assertions above)
    # and, because the freqs start at 0, f can be used to index to find it&#39;s corresponding
    # position
    current_f1 = spec[f]

    # return abs difference betwee target (f1) and current f1
    return np.abs(current_f1 - f1)


# &gt;&gt; Optimisation function
def find_real_f1(c, f1, t=None, method=&#34;Nelder-Mead&#34;):
    &#34;&#34;&#34;Find amplitue of underlying sin for reported f1

    Uses mean full-field firing rate (c) and reported F1.
    Assuming rectification, the true underlying amplitude is determined
    using optimisation

    Returns
    ----
    result for a (amplitude) as a single value
    full optimisation results
    &#34;&#34;&#34;

    t = (np.arange(0, 1, 1 / 1000)
         if t is None
         else t
         )

    assert np.isclose((t[1] - t[0]) * t.size, 1), (
        &#39;t (time) must have time length 1 and d = 1/n \n&#39;,
        f&#39;Currently size (n): {t.size}, d: {t[1] - t[0]} and d*n: {t.size * (t[1]-t[0])}&#39;)

    # only free parameter is a (amplitude) ... as we&#39;re fitting a to given f1
    ojb_f = partial(gen_f1_diff, c=c, t=t, f1=f1, f=1)

    opt_results = minimize(ojb_f, np.array([40]), method=method)

    return opt_results.x[0], opt_results


# &gt;&gt; interactive

def show_f1_opt(a, c, t, f1, f, view_max=10, figsize=(12, 5)):

    # signal = gen_sin(a, c, t, f=f)
    # signal[signal &lt; 0] = 0

    # spec, freq = gen_fft(signal, t, view_max=view_max)

    signal, spec, freq = gen_rect_sig_fft(a, c, t, f, view_max=view_max)
    current_f1 = spec[f]

    plt.figure(figsize=figsize)

    plt.subplot(121)
    plt.plot(t, signal)
    plt.axhline(c, c=&#39;0.65&#39;, ls=&#39;:&#39;)
    plt.ylim(top=a * 3)

    plt.subplot(122)
    plt.plot(freq, np.abs(spec))
    plt.axhline(f1, c=&#39;r&#39;, ls=&#39;:&#39;)

    plt.title(f&#39;|{f1:.3f}-{current_f1:.3f}|={np.abs(f1-current_f1):.3f}&#39;)


def gen_interactive_f1_opt(
        f1, c, a=(0, 100, 0.5),
        view_max=10, f=1, t=(0, 1, 1 / 1000),
        figsize=(15, 8)):

    f1, c, f = fixed(f1), fixed(c), fixed(f)
    t = fixed(np.arange(*t))
    figsize = fixed(figsize)
    view_max = fixed(view_max)

    interact(
        show_f1_opt,
        a=a, c=c, t=t, f1=f1, f=f,
        view_max=view_max, figsize=figsize)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lif.lif_utils.find_real_f1"><code class="name flex">
<span>def <span class="ident">find_real_f1</span></span>(<span>c, f1, t=None, method='Nelder-Mead')</span>
</code></dt>
<dd>
<div class="desc"><p>Find amplitue of underlying sin for reported f1</p>
<p>Uses mean full-field firing rate (c) and reported F1.
Assuming rectification, the true underlying amplitude is determined
using optimisation</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>result for a (amplitude) as a single value</code></dt>
<dd>&nbsp;</dd>
<dt><code>full optimisation results</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_real_f1(c, f1, t=None, method=&#34;Nelder-Mead&#34;):
    &#34;&#34;&#34;Find amplitue of underlying sin for reported f1

    Uses mean full-field firing rate (c) and reported F1.
    Assuming rectification, the true underlying amplitude is determined
    using optimisation

    Returns
    ----
    result for a (amplitude) as a single value
    full optimisation results
    &#34;&#34;&#34;

    t = (np.arange(0, 1, 1 / 1000)
         if t is None
         else t
         )

    assert np.isclose((t[1] - t[0]) * t.size, 1), (
        &#39;t (time) must have time length 1 and d = 1/n \n&#39;,
        f&#39;Currently size (n): {t.size}, d: {t[1] - t[0]} and d*n: {t.size * (t[1]-t[0])}&#39;)

    # only free parameter is a (amplitude) ... as we&#39;re fitting a to given f1
    ojb_f = partial(gen_f1_diff, c=c, t=t, f1=f1, f=1)

    opt_results = minimize(ojb_f, np.array([40]), method=method)

    return opt_results.x[0], opt_results</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_f1_diff"><code class="name flex">
<span>def <span class="ident">gen_f1_diff</span></span>(<span>a, c, t, f1, f=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Find diff between target f1 and f1 of rectified sin</p>
<p>a, c, t, f -&gt; gen_sin</p>
<p>f1: target f1</p>
<p>frequency (f) is vital to this process, as it is the frequency that defines
the F1 of the signal.
frequency must be set so that it is guaranteed to be available from the fft.</p>
<p>To do this, f must be set to an integer (1 here), AND,
the total length of t (in time) must be 1, which ensures that the number of
samples (n) and their period (d) are inversions of each other (n = 1/d).
This ensures that the frequencies available from the fft are:
0, 1, 2, &hellip;, n/2-1, n/2 (see docs for np.fft.rfftfreq)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_f1_diff(a, c, t, f1, f=1):
    &#34;&#34;&#34;Find diff between target f1 and f1 of rectified sin

    a, c, t, f -&gt; gen_sin

    f1: target f1

    frequency (f) is vital to this process, as it is the frequency that defines
    the F1 of the signal.
    frequency must be set so that it is guaranteed to be available from the fft.

    To do this, f must be set to an integer (1 here), AND,
    the total length of t (in time) must be 1, which ensures that the number of
    samples (n) and their period (d) are inversions of each other (n = 1/d).
    This ensures that the frequencies available from the fft are:
    0, 1, 2, ..., n/2-1, n/2 (see docs for np.fft.rfftfreq)
    &#34;&#34;&#34;

    # signal = gen_sin(a, c, t, f=f)
    # signal[signal &lt; 0] = 0  # rectify signal

    # spec, freq = gen_fft(signal, t)

    signal, spec, freq = gen_rect_sig_fft(a, c, t, f)

    assert np.isclose((t[1] - t[0]) * t.size, 1), (
        &#39;t (time) must have time length 1 and d = 1/n \n&#39;,
        f&#39;Currently size (n): {t.size}, d: {t[1] - t[0]} and d*n: {t.size * (t[1]-t[0])}&#39;)

    assert isinstance(f, int), &#39;f must be an integer&#39;

    # this works as the freqs are 0, 1, 2 (provided assertions above)
    # and, because the freqs start at 0, f can be used to index to find it&#39;s corresponding
    # position
    current_f1 = spec[f]

    # return abs difference betwee target (f1) and current f1
    return np.abs(current_f1 - f1)</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_fft"><code class="name flex">
<span>def <span class="ident">gen_fft</span></span>(<span>s, t, view_max=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate fft spectrum and frequency axis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>signal</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>time dimension over which signal modulates</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>view_max</code></strong> :&ensp;<code>max number</code> of <code>frequency increments returned</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>spectrum:</code></dt>
<dd>
<p>normalised by size of signal array and mirroring of real signals
in imaginary and complex (ie, multiplied by 2)
Magnitude of 0Hz is not multiplied though, as not mirrored</p>
<p>absolute values returned</p>
</dd>
<dt><code>freq:</code></dt>
<dd>frequencies corresponding to spectrum values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_fft(s, t, view_max=20):
    &#34;&#34;&#34;Generate fft spectrum and frequency axis

    Parameters
    ----
    s: signal
    t: time dimension over which signal modulates
    view_max: max number of frequency increments returned

    Returns
    ----
    spectrum:
        normalised by size of signal array and mirroring of real signals
        in imaginary and complex (ie, multiplied by 2)
        Magnitude of 0Hz is not multiplied though, as not mirrored

        absolute values returned

    freq:
        frequencies corresponding to spectrum values
    &#34;&#34;&#34;

    norm_factor = t.size

    spec = fft.rfft(s)
    # spec = fft.fftshift(fft.fft(s))
    spec[1:] *= 2 / norm_factor  # to normalise the split / coonjugate values
    spec[0] /= norm_factor
    spec = np.abs(spec)

    freq = fft.rfftfreq(t.size, (t[1] - t[0]))
    # freq = fft.fftfreq(t.size, (t[1]-t[0]))

    return spec[:view_max], freq[:view_max]</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_freq_report"><code class="name flex">
<span>def <span class="ident">gen_freq_report</span></span>(<span>n, d, print_rep=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reports description of freq range for a signal</p>
<p>Should correspond with functions like <code>np.fft.rfftfreq</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>number</code> of <code>samples</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>distance between samples (inverse</code> of <code>sample frequency)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>min_freq</code></strong>, <strong><code>max_freq</code></strong>, <strong><code>num_freqs</code></strong> :&ensp;<code>float, float, int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>min = 1 / (nd)
If d = resolution and n = extent / resolution,
then n * d = extent
then min = 1 / extent</p>
<p>step and min are the same</p>
<p>max = 1 / (2d) if n is even
max = (n-1) / (2dn) if n is odd</p>
<p>n_freqs = floor(n / 2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_freq_report(n, d, print_rep=True):
    &#39;&#39;&#39;Reports description of freq range for a signal

    Should correspond with functions like `np.fft.rfftfreq`

    Parameters
    ----
    n : number of samples
    d : distance between samples (inverse of sample frequency)

    Returns
    ----
    min_freq, max_freq, num_freqs : float, float, int

    Notes
    ----
    min = 1 / (nd)
    If d = resolution and n = extent / resolution,
    then n * d = extent
    then min = 1 / extent

    step and min are the same

    max = 1 / (2d) if n is even
    max = (n-1) / (2dn) if n is odd

    n_freqs = floor(n / 2)
    &#39;&#39;&#39;

    min_freq = step_freq = 1 / (d * n)
    # depends on whether n is odd or even
    max_freq = 1 / (2 * d) if (n % 2 == 0) else (n - 1) / (2 * d * n)
    num_freqs = n // 2

    if print_rep:
        print(f&#34;&#34;&#34;
        min:  {min_freq:.3f}
        step: {step_freq:.3f}
        max:  {max_freq:.3f}
        num:  {num_freqs} (plus zero)
        &#34;&#34;&#34;)

    return min_freq, max_freq, num_freqs</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_interactive_f1_opt"><code class="name flex">
<span>def <span class="ident">gen_interactive_f1_opt</span></span>(<span>f1, c, a=(0, 100, 0.5), view_max=10, f=1, t=(0, 1, 0.001), figsize=(15, 8))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_interactive_f1_opt(
        f1, c, a=(0, 100, 0.5),
        view_max=10, f=1, t=(0, 1, 1 / 1000),
        figsize=(15, 8)):

    f1, c, f = fixed(f1), fixed(c), fixed(f)
    t = fixed(np.arange(*t))
    figsize = fixed(figsize)
    view_max = fixed(view_max)

    interact(
        show_f1_opt,
        a=a, c=c, t=t, f1=f1, f=f,
        view_max=view_max, figsize=figsize)</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_interactive_rect_fft"><code class="name flex">
<span>def <span class="ident">gen_interactive_rect_fft</span></span>(<span>a=(0, 100, 1), c=(-5, 200, 0.1), view_max=(5, 100, 1), t=(0, 1, 0.001), figsize=(15, 8))</span>
</code></dt>
<dd>
<div class="desc"><p>Generate interactive ipywidget dashboard of rectified signal and fft</p>
<p>Argments passed to show_rect_wave_fft</p>
<p>t tuple is passed to numpy as np.arange(*t).
Thus t: (start, stop, step)</p>
<p>t and figsize are passed to interact as fixed arguments</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_interactive_rect_fft(
        a=(0, 100, 1), c=(-5, 200, 0.1),
        view_max=(5, 100, 1),
        t=(0, 1, 1 / 1000),
        figsize=(15, 8)):
    &#34;&#34;&#34;Generate interactive ipywidget dashboard of rectified signal and fft

    Argments passed to show_rect_wave_fft

    t tuple is passed to numpy as np.arange(*t).
    Thus t: (start, stop, step)

    t and figsize are passed to interact as fixed arguments

    &#34;&#34;&#34;

    t = fixed(np.arange(*t))
    figsize = fixed(figsize)

    interact(show_rect_wave_fft, a=a, c=c, view_max=view_max, t=t, figsize=figsize)</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_rect_sig_fft"><code class="name flex">
<span>def <span class="ident">gen_rect_sig_fft</span></span>(<span>a, c, t, f=1, view_max=20)</span>
</code></dt>
<dd>
<div class="desc"><p>generate rectified signal and spec for a(amp), c(trans) and t(time)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_rect_sig_fft(a, c, t, f=1, view_max=20):
    &#34;&#34;&#34;generate rectified signal and spec for a(amp), c(trans) and t(time)&#34;&#34;&#34;

    signal = gen_sin(a, c, t, f=f)
    signal[signal &lt; 0] = 0  # rectify signal

    spec, freq = gen_fft(signal, t, view_max=view_max)

    return signal, spec, freq</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.gen_sin"><code class="name flex">
<span>def <span class="ident">gen_sin</span></span>(<span>a, c, t, f=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate sinusoid with t: 1-&gt;2pi</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>amplitude</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>translation</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>time, in "seconds", with a frequency</code> of <code>1 corresponding</code></dt>
<dd>to a single cycle in 1 second of t</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>frequency</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_sin(a, c, t, f=10):
    &#34;&#34;&#34;Generate sinusoid with t: 1-&gt;2pi

    Parameters
    ----
    a: amplitude
    c: translation
    t: time, in &#34;seconds&#34;, with a frequency of 1 corresponding
        to a single cycle in 1 second of t
    f: frequency
    &#34;&#34;&#34;

    return a * np.sin(f * 2 * np.pi * t) + c</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.show_f1_opt"><code class="name flex">
<span>def <span class="ident">show_f1_opt</span></span>(<span>a, c, t, f1, f, view_max=10, figsize=(12, 5))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_f1_opt(a, c, t, f1, f, view_max=10, figsize=(12, 5)):

    # signal = gen_sin(a, c, t, f=f)
    # signal[signal &lt; 0] = 0

    # spec, freq = gen_fft(signal, t, view_max=view_max)

    signal, spec, freq = gen_rect_sig_fft(a, c, t, f, view_max=view_max)
    current_f1 = spec[f]

    plt.figure(figsize=figsize)

    plt.subplot(121)
    plt.plot(t, signal)
    plt.axhline(c, c=&#39;0.65&#39;, ls=&#39;:&#39;)
    plt.ylim(top=a * 3)

    plt.subplot(122)
    plt.plot(freq, np.abs(spec))
    plt.axhline(f1, c=&#39;r&#39;, ls=&#39;:&#39;)

    plt.title(f&#39;|{f1:.3f}-{current_f1:.3f}|={np.abs(f1-current_f1):.3f}&#39;)</code></pre>
</details>
</dd>
<dt id="lif.lif_utils.show_rect_wave_fft"><code class="name flex">
<span>def <span class="ident">show_rect_wave_fft</span></span>(<span>a, c, t, view_max, figsize=(15, 8))</span>
</code></dt>
<dd>
<div class="desc"><p>Graph effect of rectification on spectrum</p>
<p>Parameters passed to gen_sin
figsize -&gt; plt.figure</p>
<p>First graph: signal
Second graph: spectra</p>
<h2 id="signals">Signals</h2>
<p>Full
rectified at zero (rect)
centered and rectified at zero (r_sub)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_rect_wave_fft(a, c, t, view_max, figsize=(15, 8)):
    &#34;&#34;&#34;Graph effect of rectification on spectrum

    Parameters passed to gen_sin
    figsize -&gt; plt.figure

    First graph: signal
    Second graph: spectra

    Signals:
        Full
        rectified at zero (rect)
        centered and rectified at zero (r_sub)
    &#34;&#34;&#34;

    sin = gen_sin(a, c, t, f=10)

    sin_rect = sin.copy()
    sin_rect[sin_rect &lt; 0] = 0

    sin_r_sub = sin - c
    sin_r_sub[sin_r_sub &lt; 0] = 0

    spec, freq = gen_fft(sin, t, view_max=view_max)
    spec_rect, freq = gen_fft(sin_rect, t, view_max=view_max)

    spec_r_sub, freq = gen_fft(sin_r_sub, t, view_max=view_max)

    # mod ratio
    # 10 and 0, as with time window of 1000 and sample period of 1/1000, freq is in steps of 1
    sin_mr = spec[10] / spec[0]
    sin_rect_mr = spec_rect[10] / spec_rect[0]
    sin_r_sub_mr = spec_r_sub[10] / spec_r_sub[0]

    plt.figure(figsize=figsize)

    plt.subplot(121)
    plt.plot(sin, lw=2)
    plt.plot(sin_rect, &#39;:&#39;, lw=3)
    plt.plot(sin_r_sub, &#39;--&#39;, lw=3)

    plt.subplot(122)
    plt.plot(freq, spec)
    plt.plot(freq, spec_rect, label=&#39;rect&#39;)
    plt.plot(freq, spec_r_sub, label=&#39;r_sub&#39;)
    plt.legend()
    plt.title(f&#39;mr: sin: {sin_mr:.2f}, r: {sin_rect_mr:.2f}, r_sub: {sin_r_sub_mr:.2f}&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lif" href="index.html">lif</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lif.lif_utils.find_real_f1" href="#lif.lif_utils.find_real_f1">find_real_f1</a></code></li>
<li><code><a title="lif.lif_utils.gen_f1_diff" href="#lif.lif_utils.gen_f1_diff">gen_f1_diff</a></code></li>
<li><code><a title="lif.lif_utils.gen_fft" href="#lif.lif_utils.gen_fft">gen_fft</a></code></li>
<li><code><a title="lif.lif_utils.gen_freq_report" href="#lif.lif_utils.gen_freq_report">gen_freq_report</a></code></li>
<li><code><a title="lif.lif_utils.gen_interactive_f1_opt" href="#lif.lif_utils.gen_interactive_f1_opt">gen_interactive_f1_opt</a></code></li>
<li><code><a title="lif.lif_utils.gen_interactive_rect_fft" href="#lif.lif_utils.gen_interactive_rect_fft">gen_interactive_rect_fft</a></code></li>
<li><code><a title="lif.lif_utils.gen_rect_sig_fft" href="#lif.lif_utils.gen_rect_sig_fft">gen_rect_sig_fft</a></code></li>
<li><code><a title="lif.lif_utils.gen_sin" href="#lif.lif_utils.gen_sin">gen_sin</a></code></li>
<li><code><a title="lif.lif_utils.show_f1_opt" href="#lif.lif_utils.show_f1_opt">show_f1_opt</a></code></li>
<li><code><a title="lif.lif_utils.show_rect_wave_fft" href="#lif.lif_utils.show_rect_wave_fft">show_rect_wave_fft</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>