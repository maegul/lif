# LIF Architecture

## Package Structure

* `lif`
	- `receptive field`
	- `convolution`
	- `lgn_layer` _???_
	- `v1`
	- `spiking` _???_
	- `stimulus`
	- `utils`
	- `plot`


## Design "Principles"


* In filter functions, all arguments that call for units are typed as types for that unit in utils.
* filters uses filter functions but take data objects as arguments

## Spatial Coordinates

* Main functions: `mk_spat_coords` or `mk_spat_temp_coords`
	- Accept resolution and extent arguments
	- Optional sd (standard deviation of spatial filter) and sd_limit args too
* These both use, in the _Next layer_: `mk_sd_limited_spat_coords` which then wraps `mk_spat_coords_1d`:
	- `mk_sd_limited_spat_coords` will employ any sd arguments if provided to create a new spat_extent argument from the sd arguments
		+ `mk_spat_ext_from_sd_limit` is used to create the new spat_extent argument
			* The sd is multiplied by the limit (defined by an argument or standard parameter in the settings ... `~5`) and taken as the ceiling integer.  This is then doubled to return a spatial extent (as an sd is radial, but sptial extent is diametrical)
	- `mk_spat_coords_1d` is then used with an extent and resolution argument
* In using a spatial extent argument, it is first rounded to an integer multiple of the resolution argument
	- `mk_rounded_spat_radius` wraps `round_coord_to_res`
	- The extend is halved and converted into the same unit as the resolution argument
		+ _the resolution argument is somewhat the keystone to these operations_
	- `round_coord_to_res` then finds the lowest value above the provided extent (due to `high = True` argument) that is an integer multiple of the resolution and returns an `ArcLength` in the same unit as the resolution.
* Coords are then generated around `0` and extending negatively and positively to the generated spatial radius in steps of the resolution (using `np.arange`).
	- As the spatial extent is an integer multiple of the resolution, the actual extent of the coords using `np.arange` (ie, the final number in the array) will be exactly the spatial radius generated by the `mk_rounded_spat_radius` function
